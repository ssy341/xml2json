{"dt-api":{"summary":"Iterate over each selected row, with the function context set to be the row in question.","description":"A typical operation with the DataTable API is to perform an operation on a collection of rows - a common action is performed on each row, adding event handlers, updating data, etc. This iteration of the rows can be performed a number of ways in DataTables, each with its own advantages:\r\n\r\n\t\t* `dt-api rows().every()`\r\n\t\t* `dt-api iterator()`\r\n\t\t* `dt-api each()`\r\n\r\n\t\tThis `dt-api rows().every()` method is likely to be the most useful in the majority of cases as it sets the context of the callback function to be the `dt-api row()` instance for the row in question (normally a callback in the DataTables API has its context set to be at the top level API hierarchy). In simple terms this means you have the methods such as `dt-api row().data()` available as `this.data()` in the callback given to this method.\r\n\r\n\t\tConsider the following example using `dt-api each()`, which iterates over the row indexes that have been selected - we are required to get the `dt-api row()` object for each row to be able to work with it directly:\r\n\r\n\t\t```js\r\n\t\ttable.rows().eq(0).each( function ( index ) {\r\n\t\t\tvar row = table.row( index );\r\n\r\n\t\t\tvar data = row.data();\r\n\t\t\t// ... do something with data(), or row.node(), etc\r\n\t\t} );\r\n\t\t```\r\n\r\n\t\tUsing `dt-api rows().every()` this can be rewritten as:\r\n\r\n\t\t```js\r\n\t\ttable.rows().every( function ( rowIdx, tableLoop, rowLoop ) {\r\n\t\t\tvar data = this.data();\r\n\t\t\t// ... do something with data(), or this.node(), etc\r\n\t\t} );\r\n\t\t```\r\n\r\n\t\tAlthough a relatively simple optimisation in terms of code presentation, it can make the code much more readable and intuitive.\r\n\r\n\t\tThe other advantage is that the table context is automatically handled - in the first example above where `dt-api each()` is used, the `dt-api eq()` method is used to select the information from the first table in the API's context only, introducing complexity if multiple tables are used. In `dt-api rows().every()` the table context is automatically set to the appropriate table for each row that has been selected.","name":"rows().every()","example":[{"content":"\r\nvar table = $('#example').DataTable();\r\n\r\ntable.rows().every( function ( rowIdx, tableLoop, rowLoop ) {\r\n\tthis\r\n\t\t.child(\r\n\t\t\t$(\r\n\t\t\t\t'<tr>'+\r\n\t\t\t\t\t'<td>'+rowIdx+'.1<\/td>'+\r\n\t\t\t\t\t'<td>'+rowIdx+'.2<\/td>'+\r\n\t\t\t\t\t'<td>'+rowIdx+'.3<\/td>'+\r\n\t\t\t\t\t'<td>'+rowIdx+'.4<\/td>'+\r\n\t\t\t\t'<\/tr>'\r\n\t\t\t)\r\n\t\t)\r\n\t\t.show();\r\n} );\r\n\r\n","title":"Add a child row to all rows, passing in a jQuery created `dt-tag tr` element and show all child rows"},{"content":"\r\nvar table = $('#example').DataTable();\r\n\r\ntable.rows().every( function ( rowIdx, tableLoop, rowLoop ) {\r\n\tvar d = this.data();\r\n\r\n\td.counter++; // update data source for the row\r\n\r\n\tthis.invalidate(); // invalidate the data DataTables has cached for this row\r\n} );\r\n\r\n// Draw once all updates are done\r\ntable.draw();\r\n\r\n","title":"Update all rows in the table, redrawing only when complete"}],"since":"1.10.6","type":{"parameter":{"content":"Function to execute for every row selected. The function's content is set to be an API instance for the row in question.\r\n\r\n\t\t\tAs of DataTables 1.10.8 the function is passed the following parameters:\r\n\r\n\t\t\t1. Row index\r\n\t\t\t2. Table loop counter\r\n\t\t\t3. Row loop counter\r\n\r\n\t\t\tNo return value is expected or acted upon.","name":"fn","type":"function"},"description":"Iterate over each selected row","returns":{"content":"DataTables API instance of the selected rows.","type":"DataTables.Api"},"type":"function","signature":"rows().every( fn )"},"group":"rows","related":[{"content":"columns().every()","type":"api"},{"content":"cells().every()","type":"api"},{"content":"each()","type":"api"},{"content":"iterator()","type":"api"}]}}